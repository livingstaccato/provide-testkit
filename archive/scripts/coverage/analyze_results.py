#!/usr/bin/env python3
# SPDX-FileCopyrightText: Copyright (c) 2025 provide.io llc. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
#

"""Parse pytest log files and generate a comprehensive report.

This script analyzes pytest output logs generated by run_tests.sh and creates
a comprehensive coverage and test results report.

Usage:
    python analyze_results.py [LOG_DIR]

Arguments:
    LOG_DIR - Directory containing .log files (default: <tempdir>/pytest-logs)

Output:
    - Console: Formatted report with summary table and observations
    - File: REPORT.txt in the LOG_DIR

Features:
    - Parses test counts (passed/failed/skipped)
    - Extracts coverage percentages (line and branch coverage)
    - Identifies failed tests
    - Generates summary statistics
    - Highlights high/low performers"""

from dataclasses import dataclass, field
from pathlib import Path
import re
import sys
import tempfile


@dataclass
class TestResult:
    package: str
    passed: int = 0
    failed: int = 0
    skipped: int = 0
    warnings: int = 0
    errors: list[str] = field(default_factory=list)
    coverage_line: float | None = None
    coverage_branch: float | None = None
    total_coverage: float | None = None
    execution_time: str | None = None
    status: str = "UNKNOWN"

    @property
    def total_tests(self) -> int:
        return self.passed + self.failed + self.skipped

    @property
    def pass_rate(self) -> float:
        if self.total_tests == 0:
            return 0.0
        return (self.passed / self.total_tests) * 100


def parse_log_file(log_path: Path) -> TestResult:
    """Parse a single pytest log file."""
    package = log_path.stem
    result = TestResult(package=package)

    content = log_path.read_text()

    # Strip ANSI color codes
    ansi_escape = re.compile(r"\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])")
    content = ansi_escape.sub("", content)

    # Check for errors
    if "ERROR:" in content or "INTERNALERROR" in content:
        error_lines = [line for line in content.split("\n") if "ERROR" in line]
        result.errors.extend(error_lines[:5])  # First 5 errors
        if "Cannot change to directory" in content or "No such file" in content:
            result.status = "NO_TESTS"
            return result

    # Check if no tests directory exists
    if "no tests ran" in content.lower() or "no test" in content.lower():
        result.status = "NO_TESTS"
        return result

    # Parse test summary line
    # Formats: "===== 1 failed, 5737 passed, 75 skipped, 48 warnings in 209.24s ====="
    #          "======== 34 failed, 992 passed, 3 skipped, 1 error in 93.71s ========"
    #          "======================== 82 passed in 65.01s ========================="
    #          "==================== 128 passed, 2 skipped in 61.40s ===================="
    # Look for the pattern with passed/failed/skipped/errors
    summary_pattern = r"=+\s*(?:(\d+)\s+(?:failed|error)s?[,\s]+)?(?:(\d+)\s+passed)?(?:[,\s]+(\d+)\s+skipped)?.*?\s+in\s+([\d:.]+s)"
    summary_match = re.search(summary_pattern, content, re.IGNORECASE)

    if summary_match:
        result.failed = int(summary_match.group(1) or 0)
        result.passed = int(summary_match.group(2) or 0)
        result.skipped = int(summary_match.group(3) or 0)
        result.execution_time = summary_match.group(4)

        if result.failed > 0:
            result.status = "FAILED"
        elif result.passed > 0:
            result.status = "PASSED"

    # Parse coverage (look for "Total coverage: XX.XX%")
    total_cov_pattern = r"Total coverage:\s*([\d.]+)%"
    total_cov_match = re.search(total_cov_pattern, content)
    if total_cov_match:
        result.total_coverage = float(total_cov_match.group(1))

    # Parse detailed coverage from coverage report
    # Look for TOTAL line: "TOTAL   1234  567   89%   45%" or "TOTAL  3558    149   1496    125    94%"
    # Format can be: TOTAL <stmts> <miss> <coverage%> [<branch%>]
    # Or with branch: TOTAL <stmts> <miss> <branch> <partial> <coverage%>
    coverage_total_pattern = r"TOTAL\s+\d+\s+\d+(?:\s+\d+)?(?:\s+\d+)?\s+([\d.]+)%"
    cov_match = re.search(coverage_total_pattern, content)
    if cov_match:
        result.coverage_line = float(cov_match.group(1))

    # Extract failed test names
    failed_pattern = r"FAILED ([\w/.:-]+)"
    failed_tests = re.findall(failed_pattern, content)
    if failed_tests:
        result.errors.extend([f"FAILED: {test}" for test in failed_tests[:5]])

    return result


def generate_report(results: list[TestResult]) -> str:
    """Generate a comprehensive text report."""
    report: list[str] = [
        "=" * 100,
        "PYTEST COVERAGE REPORT - ALL PACKAGES",
        "=" * 100,
        "",
        "SUMMARY TABLE",
        "-" * 100,
        f"{'Package':<25} {'Status':<12} {'Tests':<15} {'Pass Rate':<12} {'Coverage':<12} {'Time':<12}",
        "-" * 100,
    ]

    sorted_results = sorted(results, key=lambda res: res.package)
    totals = {"passed": 0, "failed": 0, "skipped": 0}

    for result in sorted_results:
        status_emoji = {"PASSED": "‚úì", "FAILED": "‚úó", "NO_TESTS": "‚óã", "UNKNOWN": "?"}.get(result.status, "?")
        tests_str = f"{result.passed}P/{result.failed}F/{result.skipped}S" if result.total_tests > 0 else "N/A"
        pass_rate_str = f"{result.pass_rate:.1f}%" if result.total_tests > 0 else "N/A"

        coverage_str = "N/A"
        if result.total_coverage is not None:
            coverage_str = f"{result.total_coverage:.2f}%"
        elif result.coverage_line is not None:
            branch = f"/{result.coverage_branch:.1f}%" if result.coverage_branch is not None else ""
            coverage_str = f"{result.coverage_line:.1f}%{branch}"

        time_str = result.execution_time or "N/A"
        report.append(
            f"{result.package:<25} {status_emoji} {result.status:<10} {tests_str:<15} "
            f"{pass_rate_str:<12} {coverage_str:<12} {time_str:<12}"
        )

        totals["passed"] += result.passed
        totals["failed"] += result.failed
        totals["skipped"] += result.skipped

    report.extend(["-" * 100, ""])

    packages_with_tests = [res for res in results if res.total_tests > 0]
    append_overall_statistics(report, results, packages_with_tests, totals)
    append_detailed_results(report, sorted_results)
    append_observations(report, results, packages_with_tests)

    return "\n".join(report)


def append_overall_statistics(
    report: list[str],
    results: list[TestResult],
    packages_with_tests: list[TestResult],
    totals: dict[str, int],
) -> None:
    """Append aggregate data covering totals and coverage."""
    total_tests = totals["passed"] + totals["failed"] + totals["skipped"]
    avg_coverage = (
        sum(res.total_coverage or res.coverage_line or 0 for res in packages_with_tests)
        / len(packages_with_tests)
        if packages_with_tests
        else 0.0
    )

    report.append("OVERALL STATISTICS")
    report.append("-" * 100)
    report.append(f"Total Packages: {len(results)}")
    report.append(f"Packages with Tests: {len(packages_with_tests)}")
    report.append(f"Total Tests: {total_tests}")
    report.append(f"  - Passed: {totals['passed']}")
    report.append(f"  - Failed: {totals['failed']}")
    report.append(f"  - Skipped: {totals['skipped']}")
    report.append(
        f"Overall Pass Rate: {(totals['passed'] / total_tests * 100):.2f}%"
        if total_tests > 0
        else "Overall Pass Rate: N/A"
    )
    report.append(f"Average Coverage: {avg_coverage:.2f}%")
    report.append("")


def append_detailed_results(report: list[str], results: list[TestResult]) -> None:
    """Append per-package breakdown."""
    report.append("=" * 100)
    report.append("DETAILED RESULTS")
    report.append("=" * 100)
    report.append("")

    for result in results:
        report.append(f"\n### {result.package.upper()} ###")
        report.append(f"Status: {result.status}")
        report.append(f"Tests: {result.passed} passed, {result.failed} failed, {result.skipped} skipped")

        if result.coverage_line is not None:
            coverage = f"Coverage: Line {result.coverage_line:.1f}%"
            if result.coverage_branch is not None:
                coverage += f", Branch {result.coverage_branch:.1f}%"
            report.append(coverage)
        if result.total_coverage is not None:
            report.append(f"Total Coverage: {result.total_coverage:.2f}%")

        if result.execution_time:
            report.append(f"Execution Time: {result.execution_time}")

        if result.errors:
            report.append("Errors/Failed Tests:")
            for error in result.errors[:10]:
                report.append(f"  - {error}")

        report.append("")


def append_observations(
    report: list[str],
    results: list[TestResult],
    packages_with_tests: list[TestResult],
) -> None:
    """Append observation section summarizing notable signals."""
    report.append("=" * 100)
    report.append("OBSERVATIONS")
    report.append("=" * 100)
    report.append("")

    no_tests = [res for res in results if res.status == "NO_TESTS"]
    if no_tests:
        report.append(f"‚ö†Ô∏è  Packages without tests ({len(no_tests)}):")
        for entry in no_tests:
            report.append(f"  - {entry.package}")
        report.append("")

    failed = [res for res in results if res.status == "FAILED"]
    if failed:
        report.append(f"‚ùå Packages with failures ({len(failed)}):")
        for entry in failed:
            report.append(f"  - {entry.package}: {entry.failed} failed tests")
        report.append("")

    low_coverage = [
        res for res in packages_with_tests if (res.total_coverage or res.coverage_line or 100) < 70
    ]
    if low_coverage:
        report.append(f"‚ö†Ô∏è  Packages with low coverage (<70%) ({len(low_coverage)}):")
        for entry in low_coverage:
            cov_value = entry.total_coverage or entry.coverage_line or 0
            report.append(f"  - {entry.package}: {cov_value:.1f}%")
        report.append("")

    high_performers = [
        res
        for res in packages_with_tests
        if res.status == "PASSED" and (res.total_coverage or res.coverage_line or 0) >= 80
    ]
    if high_performers:
        for entry in sorted(
            high_performers, key=lambda item: -(item.total_coverage or item.coverage_line or 0)
        ):
            cov_value = entry.total_coverage or entry.coverage_line or 0
            report.append(f"  - {entry.package}: {cov_value:.1f}% coverage, {entry.total_tests} tests")
        report.append("")


def main() -> None:
    # Allow log directory to be specified via command line
    default_log_dir = Path(tempfile.gettempdir()) / "pytest-logs"
    log_dir_arg = sys.argv[1] if len(sys.argv) > 1 else str(default_log_dir)
    log_dir = Path(log_dir_arg)

    if not log_dir.exists():
        print(f"Error: Log directory not found: {log_dir}")
        sys.exit(1)

    log_files = sorted(log_dir.glob("*.log"))

    results = []
    for log_file in log_files:
        result = parse_log_file(log_file)
        results.append(result)

    report = generate_report(results)

    # Print to stdout
    print(report)

    # Save to file
    report_file = log_dir / "REPORT.txt"
    report_file.write_text(report)
    print(f"\n\nReport saved to: {report_file}")


if __name__ == "__main__":
    main()

# üß™‚úÖüîö
